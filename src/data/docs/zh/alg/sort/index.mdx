---
title: 排序
description: 
created_at: 2025-03-24T15:40:14Z
updated_at: 2025-03-24T15:40:14Z
tags: [alg,sort]
---

## 冒泡排序
**算法思想**
- 冒泡排序通过**相邻元素的比较和交换**，将较大的元素逐步“冒泡”到数组的末尾
- 每一轮都会将当前未排序部分的最大（或最小）元素放到正确的位置

**实现步骤**:
```py
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n-i-1): # 从数组的第一个元素到未排序的位置 -1, 因为最后一个元素没有下一位或者下一位是有序的，依次比较相邻的两个元素
            if arr[j] > arr[j+1]: # 如果前一个元素大于后一个元素，则交换两个元素
                arr[j], arr[j+1] = arr[j+1], arr[j]
        # 例如遍历一遍后, 最后一个元素就是最大的元素, 下一次遍历就不需要比较最后一个元素
        # 遍历两次后, 最后两个元素就是最大的两个元素, 下一次遍历就不需要比较最后两个元素
    return arr
```
## 选择排序
交换次数比冒泡排序少，但是比较次数一样多

**算法思想**:
- 选择排序每次从未排序的部分**选择最小（或最大）的元素**，放到未排序部分的起始位置
**实现步骤**:
```py
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i+1, n): # 从未排序的部分选择最小的元素
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```

## 题例 LeetCode 406. 根据身高重建队列

- 406.根据身高重建队列 - 力扣 (LeetCode) - https://leetcode.cn/problems/queue-reconstruction-by-height/description/

### 题目描述

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 $people[i] = [h_i, k_i]$ 表示第 `i` 个人的身高为 $h_i$ ，前面 **正好** 有 $k_i$ 个身高大于或等于 $h_i$ 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 $queue[j] = [h_j, k_j]$ 是队列中第 `j` 个人的属性 (`queue[0]{:py}` 是排在队列前面的人)。

### 输入输出样例

1. 示例 1:
```
输入: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```
2. 示例 2:
```
输入: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```
### 提示：

- $1 ≤ people.length ≤ 2000$
- $0 ≤ h_i ≤ 10^6$
- $0 ≤ k_i < people.length$
- 题目数据确保队列可以被重建

### 分析

1. 排在前面的 $k_i$ 会比较小, 而排在后面的 $k_i$ 会比较大, 因此 排在前面的 $h_i$ 需要比较大.
2. 对于 $h_i$ 相同的情况, $k_i$ 较大的必须排在后面
3. 对于 $k_i$ 相同的情况, 排序没有直接关系
4. 进行 $h_i$ 的降序排序, 对于 $h_i$ 相同的情况, 对 $k_i$ 升序排序后, 进行插入操作, 来保证

#### 做法

```py
import sys
input = lambda: sys.stdin.readline().strip()
from typing import List

people: List[List[int]] = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
# 1. 先对 h_i 降序排序, 对于 h_i 相同的情况, 对 k_i 升序排序
people.sort(key=lambda x: (-x[0], x[1]))
# 2. 
res = []
for i,v in enumerate(people):
   h, k = v[0], v[1]
   if k >= len(res):
       res.append(v) # 这样虽然不能保证满足要求, 但是题目说了是数据是来自正确的队列, 打乱后的, 因为等其他插入完成后, 最终就能还原了
   else:
       res.insert(k, v) # 插入到 k 的位置, 这样前面就有 k 个大于等于 h 的元素
print(res)
```

```go
people := []string{"Alice", "Bob", "Charlie"}
for i, v := range people {
    fmt.Println(i, v)
}
```