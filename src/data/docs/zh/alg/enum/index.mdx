---
title: 穷举法
description: 这是一个非常好的起点！暴力枚举是解决算法问题的基础方法之一，尤其是在解空间有限的情况下。虽然暴力枚举通常不是最优解，但它是理解问题和验证复杂算法的关键工具。
created_at: 2025-03-22T16:40:54Z
updated_at: 2025-03-22T16:40:54Z
tags: [alg,enum]
---

以下是关于**如何学习暴力枚举**的详细指导：

---

## 什么是暴力枚举？

暴力枚举（Brute Force）是一种**穷举法**，即尝试所有可能的解，逐一验证每个解是否满足问题的条件。它的核心思想是：
1. **生成所有可能的解**。
2. **逐一验证每个解是否满足条件**。
3. **返回满足条件的解（或最优解）**。

---

## 学习暴力枚举的步骤

### **理解问题的解空间**
- 解空间是指问题所有可能解的集合。
- 在暴力枚举中，你需要明确解空间的大小，以及如何生成所有可能的解。

**示例**：
- 如果问题是“从数组 `[1, 2, 3]{:py}` 中选择两个数”，解空间是所有可能的数对：`(1, 2), (1, 3), (2, 3){:py}`。
- 如果问题是“排列字符串 `abc{:.str}` 的所有可能顺序”，解空间是所有排列：`abc, acb, bac, bca, cab, cba{:.str}`。

---

### **生成所有可能的解**
- 使用循环、递归或组合工具生成解空间。
- 常见的生成方法：
  - **单层循环**：用于简单的线性枚举。
  - **多层嵌套循环**：用于枚举多维解空间。
  - **递归**：用于生成排列、组合等复杂解空间。
  - **工具库**：如 Python 的 `itertools`。

**示例**：
- **单层循环**：
  ```python
  for i in range(1, 5):  # 枚举 1 到 4
      print(i)
  ```

- **多层嵌套循环**：
  ```python
  for i in range(1, 4):  # 第一层
      for j in range(1, 4):  # 第二层
          print(i, j)  # 枚举所有 (i, j) 对
  ```

- **递归生成排列**：
  ```python
  def permute(nums, path=[]):
      if not nums:
          print(path)  # 输出一个排列
          return
      for i in range(len(nums)):
          permute(nums[:i] + nums[i+1:], path + [nums[i]])

  permute([1, 2, 3])  # 输出 [1, 2, 3] 的所有排列
  ```

- **使用工具库**：
  ```python
  from itertools import permutations

  for p in permutations([1, 2, 3]):
      print(p)  # 输出 [1, 2, 3] 的所有排列
  ```

---

### **验证解是否满足条件**
- 对每个生成的解，验证它是否满足题目要求。
- 验证逻辑通常是一个条件判断（`if` 语句）。

**示例**：
- 验证一个数是否是偶数：
  ```python
  for i in range(1, 10):
      if i % 2 == 0:  # 验证是否是偶数
          print(i)
  ```

- 验证一个排列是否满足特定条件：
  ```python
  from itertools import permutations

  for p in permutations([1, 2, 3]):
      if p[0] < p[1]:  # 验证第一个数小于第二个数
          print(p)
  ```

---

### **优化暴力枚举**
暴力枚举的核心问题是**效率低**，尤其是当解空间很大时。因此，学习暴力枚举时，也需要掌握一些优化技巧：
- **剪枝**：在生成解的过程中，提前排除不可能的解。
  ```python
  for i in range(1, 10):
      if i % 2 != 0:  # 剪枝：跳过奇数
          continue
      print(i)
  ```

- **提前终止**：如果找到一个解就可以结束枚举，则不需要继续。
  ```python
  for i in range(1, 10):
      if i == 5:  # 找到解后终止
          print("Found:", i)
          break
  ```

- **减少嵌套循环**：通过数学公式或逻辑简化枚举过程。

---

## 学习暴力枚举的练习题

### **简单枚举**
- **题目**：枚举 1 到 100 中所有的偶数。
  ```python
  for i in range(1, 101):
      if i % 2 == 0:
          print(i)
  ```

### **多层枚举**
- **题目**：枚举所有两位数的组合。
  ```python
  for i in range(10, 100):
      for j in range(10, 100):
          print(i, j)
  ```

### **排列与组合**
- **题目**：生成数组 `[1, 2, 3]` 的所有排列。
  ```python
  from itertools import permutations

  for p in permutations([1, 2, 3]):
      print(p)
  ```

### **验证条件**
- **题目**：从数组 `[1, 2, 3, 4]` 中选择两个数，要求它们的和为 5。
  ```python
  for i in range(1, 5):
      for j in range(i + 1, 5):
          if i + j == 5:
              print(i, j)
  ```

### **复杂枚举**
- **题目**：生成长度为 3 的二进制字符串。
  ```python
  for i in range(2):
      for j in range(2):
          for k in range(2):
              print(f"{i}{j}{k}")
  ```

---

## 学习暴力枚举的资源

1. **书籍**：
   - 《算法导论》（Introduction to Algorithms）—— Thomas H. Cormen
   - 《编程之美》—— Microsoft Research

2. **在线平台**：
   - **LeetCode**：从简单题目开始，逐步挑战更复杂的题目。
   - **HackerRank**：适合练习基础算法和枚举问题。
   - **Codeforces**：适合练习竞赛题目。

3. **工具**：
   - 使用 Python 的 `itertools` 库简化排列和组合的生成。
   - 使用可视化工具（如 [VisuAlgo](https://visualgo.net/)）帮助理解枚举过程。

---

## 学习路径建议

1. **从简单问题开始**：
   - 练习单层循环和多层循环的枚举。
   - 理解如何生成解空间。

2. **逐步增加复杂度**：
   - 学习排列、组合的生成方法。
   - 练习验证条件的逻辑。

3. **优化暴力枚举**：
   - 学习剪枝和提前终止的技巧。
   - 理解如何减少不必要的计算。

4. **结合实际问题**：
   - 在实际问题中应用暴力枚举，逐步积累经验。

---

## 总结

暴力枚举是算法学习的基础，掌握它可以帮助你更好地理解问题和验证复杂算法。学习暴力枚举的关键是：
1. **理解解空间**：明确所有可能的解。
2. **生成解空间**：使用循环、递归或工具库生成解。
3. **验证解**：逐一验证每个解是否满足条件。
4. **优化枚举**：通过剪枝和提前终止提高效率。

通过不断练习和总结，你会发现暴力枚举不仅简单，而且非常实用。如果你有具体的题目或问题，可以随时告诉我，我会帮助你分析和解答！

## 竞赛题

刑侦科推理试题-lanqiao-1792

### 题目描述
```md
有以下10道单选题，编程求这10道题的答案。
1. 这道题的答案是：
A. A  B. B   C. C  D. D
2. 第5题的答案是：
A. C  B. D  C. A  D. B
3. 以下选项中哪一题的答案与其他三项不同：
A. 第3题  B. 第6题  C. 第2题  D. 第4题
4. 以下选项中哪两题的答案相同：
A. 第1、5题 B. 第2、7题 C. 第1、9题 D. 第6、10题
5. 以下选项中哪一题的答案与本题相同：
A. 第8题  B. 第4题  C. 第9题 D. 第7题
6. 以下选项中哪两题的答案与第8题相同：
A. 第2、4题  B. 第1、6题  C. 第3、10题 D. 第5、9题
7. 在这十道题中，被选中次数最少的选项字母为：
A. C B. B C. A D. D
8. 以下选项中哪一题的答案与第1题的答案在字母中不相邻：
A. 第7题 B. 第5题 C. 第2题 D. 第10题
9. 已知“第1题与第6题的答案相同”与“第X题与第5题的答案相同”的真假性相反，那么X为：
A. 第6题 B. 第10题 C. 第2题 D. 第9题
10. 在这10道题的答案中，ABCD四个字母出现次数最多与最少者的差为：
A. 3 B. 2 C. 4 D. 1
```
### 输入描述

无输入。
### 输出描述

输出这10道题的答案，用空格隔开。输出示例：B C A C A C D A B A。（显然这不是本题的答案）
### 知识点

- 命题的表示
- 命题的真值
- 枚举

### 运行限制

- 最大运行时间: 1s
- 最大运行内存: 32M

### 解答

> [!TIP]
> 我没有进行优化

```py
from itertools import product
from typing import Tuple

# py3.8写法 Tuple[str, ...]; py3.9写法 tuple[str] 即不用导入 Tuple
def is_valid(answers: Tuple[str, ...]) -> bool:
    # 将答案映射到题目中 题目从 1 开始编号
    q1, q2, q3, q4, q5, q6, q7, q8, q9, q10 = answers
    q_list = list(answers)

    # 规则 1: 第1题的答案是 A. A B. B C. C D. D
    # if q1 not in 'ABCD':
    #     return False

    # 规则 2: 第5题的答案是 A. C B. D C. A D. B
    if q5 != {'A': 'C', 'B': 'D', 'C': 'A', 'D': 'B'}[q2]:
        return False

    # 规则 3: 以下选项中哪一题的答案与其他三项不同
    # q3_dict = { 'A': q3, 'B': q6, 'C': q2, 'D': q4 }
    other_answers = { 'A': [q6, q2, q4], 'B': [q3, q2, q4], 'C': [q3, q6, q4],  'D': [q3, q6, q2] }
    def existentiallySame(q3:str):
        return q3 in other_answers[q3]
    if existentiallySame(q3):
        return False

    # 规则 4: 以下选项中哪两题的答案相同
    q4_dict = { "A": (q1, q5), "B": (q2, q7), "C": (q1, q9), "D": (q6, q10)}
    def both_questions_not_same(qn1:str,qn2:str):
        return not qn1==qn2
    if both_questions_not_same(*q4_dict[q4]):
        return False

    # 规则 5: 以下选项中哪一题的答案与本题相同
    q5_dict = {"A": q8, "B": q4, "C": q9, "D": q7}
    if q5_dict[q5]!=q5:
        return False
    
    # 规则 6: 以下选项中哪两题的答案与第8题相同
    q6_dict = { "A": (q2,q4), "B": (q1, q6), "C": (q3, q10), "D": (q5, q9)}
    def not_eq8(qn1:str,qn2:str):
        return not qn1==qn2==q8
    if not_eq8(*q6_dict[q6]):
        return False

    # 规则 7: 在这十道题中，被选中次数最少的选项字母为
    # tip: 这里可以只比较值, 因为只要拿到最小值, 然后对应的 key 都可以称为次数最少的选项字母
    counts = {c: answers.count(c) for c in 'ABCD'}
    q7_dict = {'A': "C", "B": "B", "C": "A", "D": "D"}
    if min(counts.values()) != counts[q7_dict[q7]]:
        return False

    # 规则 8: 以下选项中哪一题的答案与第1题的答案在字母中不相邻
    q8_dict = {'A': q7, "B": q5, "C": q2, "D": q10}
    def isAdjacent(qn:str):
        return abs(ord(q1)-ord(qn))==1
    if isAdjacent(q8_dict[q8]):
        return False

    # 规则 9: 已知“第1题与第6题的答案相同”与“第X题与第5题的答案相同”的真假性相反
    q9_dict = {'A': q6, "B": q10, "C": q2, "D": q9}
    is_q1_eq_q6 = q1 == q6
    def isSame(qn:str):
        return is_q1_eq_q6 == (qn == q5)
    
    if isSame(q9_dict[q9]):
        return False

    # 规则 10: 在这10道题的答案中，ABCD四个字母出现次数最多与最少者的差为
    d = max(counts.values()) - min(counts.values())
    q10_dict = {'A': 3, "B": 2, "C": 4, "D": 1}
    if d != q10_dict[q10]:
        return False

    return True

# Enumerate 所有可能的答案组合
for answers in product('ABCD', repeat=10):
    if is_valid(answers):
        print(' '.join(answers))
        # break
```

### 问题描述

小蓝有一张支票，上面记录了一些数字。小蓝不小心打翻了墨水导致了支票上的一个数字被污染了，现在小蓝想通过剩下的数字来推断出那个被污染的数字。

设支票上被污染的数字为 xx ，没有被污染的数字共有 nn 个（设为 d1,d2,…,dnd1​,d2​,…,dn​ ），小蓝知道支票如果没有错误的话，上面没有被污染的数字应当是 xx 除了 11 和 xx 之外的其他所有因数，但是他无法确定支票是否错误。支票错误的情况有以下几种：

- 支票没有被污染的数字中混入了不是 xx 的因数的数字；
- 支票没有被污染的数字中缺失或重复 xx 的部分因数。

小蓝想请你帮助他判断支票是否没有错误，若没有错误，小蓝希望你能帮他求出支票上被污染的数字。
### 输入格式

第一行包含一个整数 nn ，表示没有被污染的数字的个数。

第二行包含 nn 个整数 d1,d2,…,dnd1​,d2​,…,dn​ ，表示支票上的数字。
### 输出格式
若支票没有错误，那么输出支票上被污染的数字；反之，若支票错误，被污染的数字不存在，则输出 −1−1 。
### 样例输入
```
8
8 2 12 6 4 24 16 3
```
### 样例输出
```
48
```
### 评测数据规模

对于所有评测数据， $1≤n≤300$ , $2≤d_i≤10^6$
### 运行限制
|语言 |	最大运行时间 |	最大运行内存 |
|---|---|---|
|C |	4s |	256M |
|C++ |	4s |	256M |
|Python3 |	6s |	256M |
|Java |	5s |	256M |
|PyPy3 |	6s |	256M |
|Go |	6s |	256M |
|JavaScript |	6s |	256M |

难度: 简单   标签: 思维, 数学